# 7ì¥. ë°°ì—´

- ìë£Œêµ¬ì¡°
    - ë©”ëª¨ë¦¬ ê³µê°„ ê¸°ë°˜ì˜ ì—°ì† ë°©ì‹ ğŸ‘‰Â ë°°ì—´
    - í¬ì¸í„° ê¸°ë°˜ì˜ ì—°ê²° ë°©ì‹

- ê³¼ê±° 16ë¹„íŠ¸ ì´ì „ì—, `int`ëŠ” 2ë°”ì´íŠ¸ì˜€ë‹¤.
    - ì˜¤ëŠ˜ë‚  32ë¹„íŠ¸ ì´ìƒì˜ ì‹œìŠ¤í…œì—ì„œëŠ” `int`ë¥¼ 4ë°”ì´íŠ¸ë¡œ ì‚¬ìš©í•œë‹¤.
    
    â†’ ê°€ë¦¬í‚¤ëŠ” ì£¼ì†ŒëŠ” 1ë°”ì´íŠ¸ë§ˆë‹¤ 1ì”© ì¦ê°€í•œë‹¤.(`int`í˜• ë°°ì—´)
    
- ë°°ì—´ì€ ì–´ëŠ ìœ„ì¹˜ë‚˜ O(1)ì— ì¡°íšŒê°€ ê°€ëŠ¥í•˜ë‹¤.

## ë™ì  ë°°ì—´

---

- ë°°ì—´: ê³ ì •ëœ í¬ê¸°ë§Œí¼ì˜ ì—°ì†ëœ ë©”ëª¨ë¦¬ í• ë‹¹
- ë™ì  ë°°ì—´: í¬ê¸°ë¥¼ ì§€ì •í•˜ì§€ ì•Šê³  ìë™ìœ¼ë¡œ ë¦¬ì‚¬ì´ì§•í•˜ëŠ” ë°°ì—´
    - ìë°”: `ArrayList`, C++: `std::vector`, íŒŒì´ì¬ì´ë‚˜ ë£¨ë¹„ ê°™ì€ ë™ì  í”„ë¡œê·¸ë˜ë° ì–¸ì–´: ì •ì  ë°°ì—´ ìì²´ê°€ ì—†ë‹¤.
    - ë”ë¸”ë§ì´ í•„ìš”í•  ë§Œí¼ ê³µê°„ì´ ì°¨ë©´, ìƒˆë¡œìš´ ë©”ëª¨ë¦¬ ê³µê°„ì— ë” í° í¬ê¸°ì˜ ë°°ì—´ì„ í• ë‹¹í•˜ê³  ê¸°ì¡´ ë°ì´í„°ë¥¼ ë³µì‚¬í•˜ëŠ” ì‘ì—…ì´ í•„ìš”í•˜ë¯€ë¡œ O(n) ë¹„ìš©ì´ ë°œìƒí•œë‹¤.
    - ìµœì•…ì˜ ê²½ìš° ì‚½ì… ì‹œ O(n)ì´ ë˜ì§€ë§Œ ìì£¼ ì¼ì–´ë‚˜ëŠ” ì¼ì€ ì•„ë‹˜

# 7. ë‘ ìˆ˜ì˜ í•©

---

- [https://leetcode.com/problems/two-sum/](https://leetcode.com/problems/two-sum/)
- ë§ì…ˆí•˜ì—¬ íƒ€ê¹ƒì„ ë§Œë“¤ ìˆ˜ ìˆëŠ” ë°°ì—´ì˜ ë‘ ìˆ«ì ì¸ë±ìŠ¤ë¥¼ ë¦¬í„´í•˜ë¼.
- ë‚˜ì˜ í’€ì´
    
    ```python
    class Solution:
        def twoSum(self, nums: List[int], target: int) -> List[int]:
            dic = {}
            
            for idx, n in enumerate(nums):
                if (target - n) in dic:
                    return [dic[target - n], idx]
                dic[n] = idx
    ```
    

## í’€ì´1. ë¸Œë£¨íŠ¸ í¬ìŠ¤ë¡œ ê³„ì‚°

---

- ë¸Œë£¨íŠ¸ í¬ìŠ¤: ë¬´ì°¨ë³„ ëŒ€ì… ë°©ì‹. ë§ˆì§€ë§‰ ì—˜ë¦¬ë¨¼íŠ¸ê¹Œì§€ ëª¨ë‘ ì°¨ë¡€ëŒ€ë¡œ ë¹„êµí•´ê°€ë©° ì •ë‹µì„ ì°¾ì„ ë•Œê¹Œì§€ ê³„ì† ì§„í–‰í•œë‹¤.

- ì „ì²´ ì½”ë“œ
    
    ```java
    public int[] towSum(int[] nums, int target) {
        // ì…ë ¥ê°’ ë°°ì—´ì„ ì²˜ìŒë¶€í„° ìˆœíšŒ
        for (int i = 0; i < nums.length; i++) {
            // ì…ë ¥ê°’ ë°°ì—´ì„ ê·¸ë‹¤ìŒë¶€í„° ìˆœíšŒ
            for (int j = 0; j < nums.length; j++) {
                // ë‘ ê°’ì˜ í•©ì„ ë¹„êµí•´ targetê³¼ ì¼ì¹˜í•˜ëŠ” ê²½ìš° ì •ë‹µìœ¼ë¡œ ë¦¬í„´
                if (nums[i] + nums[j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        // í•­ìƒ ì •ë‹µì´ ì¡´ì¬í•˜ë¯€ë¡œ ë„ì´ ë¦¬í„´ë˜ëŠ” ê²½ìš°ëŠ” ì—†ìŒ
        return null;
    }
    
    ```
    
    - ì‹œê°„ ë³µì¡ë„: O(n^2)
        - ì •í™•íˆëŠ” 1/2 * n^2

## í’€ì´2. ì²« ë²ˆì§¸ ìˆ˜ë¥¼ ëº€ ê²°ê³¼ í‚¤ ì¡°íšŒ

---

- ì „ì²´ ì½”ë“œ
    
    ```java
    public int[] towSum(int[] nums, int target) {
        Map<Integer, Integer> numsMap = new HashMap<>();
        // í‚¤ì™€ ê°’ì„ ë°”ê¿”ì„œ ë§µìœ¼ë¡œ ì €ì¥
        for (int i = 0; i < nums.length; i++) {
            numsMap.put(nums[i], i);
        }
        // targetì—ì„œ ì²« ë²ˆì§¸ ìˆ˜ë¥¼ ëº€ ê²°ê³¼ë¥¼ í‚¤ë¡œ ì¡°íšŒí•˜ê³  í˜„ì¬ ì¸ë±ìŠ¤ê°€ ì•„ë‹Œ ê²½ìš° ì •ë‹µìœ¼ë¡œ ë¦¬í„´
        for (int i = 0; i < nums.length; i++) {
            if (numsMap.containsKey(target - nums[i]) && i != numsMap.get(target - nums[i])) {
                return new int[]{i, numsMap.get(target - nums[i])};
            }
        }
        // í•­ìƒ ì •ë‹µì´ ì¡´ì¬í•˜ë¯€ë¡œ ë„ì´ ë¦¬í„´ë˜ëŠ” ê²½ìš°ëŠ” ì—†ìŒ
        return null;
    }
    ```
    
    - ìë°”ì—ì„œ `HashMap`ì€ ë‚´ë¶€ì ìœ¼ë¡œ í•´ì‹œ í…Œì´ë¸”ë¡œ êµ¬í˜„ë˜ì–´ ìˆë‹¤.
        - ì¡°íšŒëŠ” í‰ê· ì ìœ¼ë¡œ O(1)ì— ê°€ëŠ¥í•˜ë‹¤.
            - ìµœì•…ì˜ ê²½ìš°ì—ëŠ” O(n)ì´ ë  ìˆ˜ ìˆì§€ë§Œ ë§ ê·¸ëŒ€ë¡œ ìµœì•…ì˜ ê²½ìš°ì´ê³  ë“œë¬¸ ê²½ìš°ì´ë¯€ë¡œ, ë¶„í•  ìƒí™˜ ë¶„ì„ì— ë”°ë¥¸ ì‹œê°„ ë³µì¡ë„ëŠ” O(1)
    - ì „ì²´ëŠ” O(n)ì´ ëœë‹¤.

## í’€ì´3. ì¡°íšŒ êµ¬ì¡° ê°œì„ 

---

- ë§µ ì €ì¥ê³¼ ì¡°íšŒë¥¼ 2ê°œì˜ `for` ë¬¸ìœ¼ë¡œ ê°ê° ì²˜ë¦¬í–ˆë˜ ë°©ì‹ì„ ì¢€ ë” ê°œì„ í•´ ì´ë²ˆì—ëŠ” í•˜ë‚˜ì˜ `for`ë¡œ í•©ì³ì„œ ì²˜ë¦¬í•´ë³´ì.
- ë™ì¼í•œ O(n)ì—ì„œ ì•½ê°„ì˜ ì°¨ì´ë§Œ ìˆì„ ë¿ì´ë¼ ì„±ëŠ¥ìƒ í° ì´ì ì€ ì—†ê² ë‹¤.

- ì „ì²´ ì½”ë“œ
    
    ```java
    public int[] towSum(int[] nums, int target) {
        Map<Integer, Integer> numsMap = new HashMap<>();
        // í•˜ë‚˜ì˜ for ë°˜ë³µìœ¼ë¡œ í†µí•©
        for (int i = 0; i < nums.length; i++) {
            // targetì—ì„œ numì„ ëº€ ê°’ì´ ìˆìœ¼ë©´ ì •ë‹µìœ¼ë¡œ ë¦¬í„´ 
            if (numsMap.containsKey(target - nums[i])) {
                return new int[]{numsMap.get(target - nums[i]), i};
            }
            // ì •ë‹µì´ ì•„ë‹ˆë¯€ë¡œ ë‹¤ìŒë²ˆ ë¹„êµë¥¼ ìœ„í•´ ì¸ë±ìŠ¤ë¥¼ ë§µì— ì €ì¥
            numsMap.put(nums[i], i);
        }
        // í•­ìƒ ì •ë‹µì´ ì¡´ì¬í•˜ë¯€ë¡œ ë„ì´ ë¦¬í„´ë˜ëŠ” ê²½ìš°ëŠ” ì—†ìŒ
        return null;
    }
    ```
    

## í’€ì´4. íˆ¬ í¬ì¸í„° ì´ìš©

---

- íˆ¬ í¬ì¸í„°: ì™¼ìª½ í¬ì¸í„°ì™€ ì˜¤ë¥¸ìª½ í¬ì¸í„°ì˜ í•©ì´ íƒ€ê¹ƒë³´ë‹¤ í¬ë‹¤ë©´ ì˜¤ë¥¸ìª½ í¬ì¸í„°ë¥¼ ì™¼ìª½ìœ¼ë¡œ, ì‘ë‹¤ë©´ ì™¼ìª½ í¬ì¸í„°ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì˜®ê¸°ë©´ì„œ ê°’ì„ ì¡°ì •í•˜ëŠ” ë°©ì‹
    - ê·¸ëŸ¬ë‚˜ ì´ ë¬¸ì œëŠ” íˆ¬ í¬ì¸í„°ë¡œ í’€ ìˆ˜ ì—†ë‹¤.
    - ì™œëƒí•˜ë©´ íˆ¬ í¬ì¸í„°ëŠ” ì£¼ë¡œ ì •ë ¬ëœ ì…ë ¥ê°’ì„ ëŒ€ìƒìœ¼ë¡œ í•˜ë©°, numsëŠ” ì •ë ¬ëœ ìƒíƒœê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì´ë‹¤.

## í’€ì´5. ì½”í‹€ë¦° í’€ì´

---

- ì „ì²´ ì½”ë“œ
    
    ```kotlin
    fun towSum(nums: IntArray, target: Int): IntArray {
        val numsMap: MutableMap<Int, Int> = mutableMapOf()
        // í•˜ë‚˜ì˜ for ë°˜ë³µìœ¼ë¡œ í†µí•©
        for ((i, num) in nums.withIndex()) {
            // targetì—ì„œ numì„ ëº€ ê°’ì´ ìˆìœ¼ë©´ ì •ë‹µìœ¼ë¡œ ë¦¬í„´ 
            if (numsMap.containsKey(target - num)) {
                return intArrayOf(numsMap[target - num] ?: 0, i)
            }
            // ì •ë‹µì´ ì•„ë‹ˆë¯€ë¡œ ë‹¤ìŒë²ˆ ë¹„êµë¥¼ ìœ„í•´ ì¸ë±ìŠ¤ë¥¼ ë§µì— ì €ì¥
            numsMap[num] = i
        }
        // í•­ìƒ ì •ë‹µì´ ì¡´ì¬í•˜ë¯€ë¡œ ì´ ê°’ì´ ë¦¬í„´ë˜ëŠ” ê²½ìš°ëŠ” ì—†ìŒ
        return intArrayOf(0, 0)
    }
    ```
    
    - ì½”í‹€ë¦°ì€ ë§ˆì¹˜ íŒŒì´ì¬ì˜ `enumerate()`ì²˜ëŸ¼ `withIndex()`ë¥¼ ë¶€ì—¬í•˜ë©´ ì¸ë±ìŠ¤ì™€ ê°’ì„ ë™ì‹œì— ì¶”ì¶œí•  ìˆ˜ ìˆë‹¤.
    - ì—˜ë¹„ìŠ¤ ì—°ì‚°ìë¥¼ í™œìš©í•´ ê¸°ë³¸ê°’ì„ 0ìœ¼ë¡œ ì„¤ì •í–ˆë‹¤.
        - ì‚¬ì‹¤ ì´ ê°’ì€ ë°˜ë“œì‹œ ì¡´ì¬í•˜ê¸° ë•Œë¬¸ì— ë„ì´ ë  ìˆ˜ ì—†ì§€ë§Œ í–‰ì—¬ë‚˜ ë°œìƒí• ì§€ ëª¨ë¥¼ NPEë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ ê¸°ë³¸ê°’ì„ 0ìœ¼ë¡œ ì„ ì–¸í–ˆë‹¤.

| í’€ì´ | ë°©ì‹ | ì‹¤í–‰ ì‹œê°„ |
| --- | --- | --- |
| 1 | ë¸Œë£¨íŠ¸ í¬ìŠ¤ë¡œ ê³„ì‚° | 90ë°€ë¦¬ì´ˆ |
| 2 | ì²« ë²ˆì§¸ ìˆ˜ë¥¼ ëº€ ê²°ê³¼ í‚¤ ì¡°íšŒ | 11ë°€ë¦¬ì´ˆ |
| 3 | ì¡°íšŒ êµ¬ì¡° ê°œì„  | 6ë°€ë¦¬ì´ˆ |
| 4 | íˆ¬ í¬ì¸í„° ì´ìš© | í’€ì´ ë¶ˆê°€ |
| 5 | ì½”í‹€ë¦° í’€ì´ | ì¸¡ì •í•˜ì§€ ì•ŠìŒ |

# 8. ë¹—ë¬¼ íŠ¸ë˜í•‘

---

- [https://leetcode.com/problems/trapping-rain-water/](https://leetcode.com/problems/trapping-rain-water/)
- ë†’ì´ë¥¼ ì…ë ¥ë°›ì•„ ë¹„ ì˜¨ í›„ ì–¼ë§ˆë‚˜ ë§ì€ ë¬¼ì´ ìŒ“ì¼ ìˆ˜ ìˆëŠ”ì§€ ê³„ì‚°í•˜ë¼.
- ë‚˜ì˜ í’€ì´
    
    ```python
    def trap(self, height: List[int]) -> int:
        volume = 0
        left = 0
        right = len(height) - 1
        leftMax = height[left]
        rightMax = height[right]
    
        while left < right:
            leftMax = max(height[left], leftMax)
            rightMax = max(height[right], rightMax)
    
            if leftMax < rightMax:
                volume += leftMax - height[left]
                left += 1
            else:
                volume += rightMax - height[right]
                right -= 1
    
        return volume
    ```
    

## í’€ì´1. íˆ¬ í¬ì¸í„°ë¥¼ ìµœëŒ€ë¡œ ì´ë™

---

- ì´ ë¬¸ì œëŠ” ë†’ì´ì™€ ë„ˆë¹„ ëª¨ë“  ê³µê°„ì„ ì°¨ë¡€ëŒ€ë¡œ ëª¨ë‘ ì‚´í´ë³´ë©´ O(n^2)ì— í’€ì´ê°€ ê°€ëŠ¥í•˜ë‹¤. ê·¸ëŸ¬ë‚˜ ì‹œê°„ ë³µì¡ë„ê°€ ë„ˆë¬´ ë†’ê¸° ë•Œë¬¸ì— ì¢€ ë” íš¨ìœ¨ì ì¸ í’€ì´ë¥¼ ì°¾ì•„ì•¼ í•œë‹¤.
- ë§‰ëŒ€ëŠ” ë†’ê³  ë‚®ìŒì— ë¬´ê´€í•˜ê²Œ, ì „ì²´ ë¶€í”¼ì— ì˜í–¥ì„ ë¼ì¹˜ì§€ ì•Šìœ¼ë©´ì„œ ê·¸ì € ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ì„ ê°€ë¥´ëŠ” ì¥ë²½ ì—­í• ì„ í•œë‹¤.
    
    ```java
    volume += leftMax - height[left]
    ...
    volume += rightMax - height[right]
    ```
    
- ì´ì²˜ëŸ¼ ìµœëŒ€ ë†’ì´ì˜ ë§‰ëŒ€ê¹Œì§€ ê°ê° ì¢Œìš° ë§‰ëŒ€ ìµœëŒ€ ë†’ì´ leftMax, rightMaxê°€ í˜„ì¬ ë†’ì´ì™€ì˜ ì°¨ì´ë§Œí¼ ë¬¼ ë†’ì´ volumeì„ ë”í•´ë‚˜ê°„ë‹¤.
    
    ```java
    if (leftMax <= rightMax) {
        volume += leftMax - height[left];
        left += 1;
    } else {
        volume += rightMax - height[right];
        right -= 1;
    }
    ```
    
- ì´ë ‡ê²Œ í•˜ë©´ ê°€ì¥ ë†’ì´ê°€ ë†’ì€ ë§‰ëŒ€, ì¦‰ 'ìµœëŒ€' ì§€ì ì—ì„œ ì¢Œìš° í¬ì¸í„°ê°€ ì„œë¡œ ë§Œë‚˜ê²Œ ë˜ë©° O(n)ì— í’€ì´ê°€ ê°€ëŠ¥í•˜ë‹¤.

- ì „ì²´ ì½”ë“œ
    
    ```java
    public int trap(int[] height) {
        int volume = 0;
        int left = 0;
        int right = height.length - 1;
        int leftMax = height[left];
        int rightMax = height[right];
    
        // íˆ¬ í¬ì¸í„°ê°€ ì„œë¡œ ê²¹ì¹  ë•Œê¹Œì§€ ë°˜ë³µ
        while (left < right) {
            leftMax = Math.max(height[left], leftMax);
            rightMax = Math.max(height[right], rightMax);
    
            // ë” ë†’ì€ ìª½ì„ í–¥í•´ íˆ¬ í¬ì¸í„° ì´ë™
            if (leftMax < rightMax) {
                // ì™¼ìª½ ë§‰ëŒ€ ìµœëŒ€ ë†’ì´ì™€ì˜ ì°¨ì´ë¥¼ ë”í•˜ê³  ì™¼ìª½ í¬ì¸í„° ì´ë™
                volume += leftMax - height[left];
                left += 1;
            } else {
                // ì˜¤ë¥¸ìª½ ë§‰ëŒ€ ìµœëŒ€ ë†’ì´ì™€ì˜ ì°¨ì´ë¥¼ ë”í•˜ê³  ì˜¤ë¥¸ìª½ í¬ì¸í„° ì´ë™
                volume += rightMax - height[right];
                right -= 1;
            }
        }
        return volume;
    }
    ```
    

## í’€ì´2. ìŠ¤íƒ ìŒ“ê¸°

---

- ìŠ¤íƒì— ìŒ“ì•„ë‚˜ê°€ë©´ì„œ í˜„ì¬ ë†’ì´ê°€ ì´ì „ ë†’ì´ë³´ë‹¤ ë†’ì„ ë•Œ, ì¦‰ êº¾ì´ëŠ” ë¶€ë¶„ ë³€ê³¡ì ì„ ê¸°ì¤€ìœ¼ë¡œ ê²©ì°¨ë§Œí¼ ë¬¼ì´ ìŒ“ì´ëŠ” ì–‘ì„ ì±„ìš´ë‹¤.
    - ì´ì „ ë†’ì´ëŠ” ê³ ì •ëœ í˜•íƒœê°€ ì•„ë‹ˆë¼ ë“¤ì‘¥ë‚ ì‘¥í•˜ê¸° ë•Œë¬¸ì—, ê³„ì† ìŠ¤íƒìœ¼ë¡œ ì±„ì›Œë‚˜ê°€ë‹¤ê°€ ë³€ê³¡ì ì„ ë§Œë‚  ë•Œë§ˆë‹¤ ìŠ¤íƒì—ì„œ í•˜ë‚˜ì”© êº¼ë‚´ë©´ì„œ ì´ì „ê³¼ì˜ ì°¨ì´ë§Œí¼ ë¬¼ì´ ìŒ“ì´ëŠ” ì–‘ì„ ì±„ì›Œë‚˜ê°„ë‹¤.
- ìŠ¤íƒìœ¼ë¡œ ì´ì „ í•­ëª©ë“¤ì„ ë˜ëŒì•„ë³´ë©° ì²´í¬í•˜ê¸°ëŠ” í•˜ì§€ë§Œ, ê¸°ë³¸ì ìœ¼ë¡œ í•œ ë²ˆë§Œ ì‚´í´ë³´ê¸° ë•Œë¬¸ì— ë§ˆì°¬ê°€ì§€ë¡œ O(n)ì— í’€ì´ê°€ ê°€ëŠ¥í•˜ë‹¤.

- ì „ì²´ ì½”ë“œ
    
    ```java
    public int trap(int[] height) {
        Deque<Integer> stack = new ArrayDeque<>();
        int volume = 0;
    
        for (int i = 0; i < height.length; i++) {
            // ë³€ê³¡ì ì„ ë§Œë‚˜ëŠ” ê²½ìš°
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                // ìŠ¤íƒì—ì„œ êº¼ë‚¸ë‹¤.
                Integer top = stack.pop();
    
                if (stack.isEmpty())
                    break;
    
                // ìŠ¤íƒì˜ ë§ˆì§€ë§‰ ìœ„ì¹˜ê¹Œì§€ë¥¼ ê±°ë¦¬ë¡œ ê³„ì‚°
                int distance = i - stack.peek() - 1;
                // í˜„ì¬ ë†’ì´ ë˜ëŠ” ìŠ¤íƒì˜ ë§ˆì§€ë§‰ ìœ„ì¹˜ ë†’ì´ ì¤‘ ë‚®ì€ ê°’ì— ë°©ê¸ˆ êº¼ë‚¸ ë†’ì´ì˜ ì°¨ì´ë¥¼ ë¬¼ ë†’ì´ë¡œ ì§€ì •
                int waters = Math.min(height[i], height[stack.peek()]) - height[top];
    
                // ë¬¼ì´ ìŒ“ì´ëŠ” ì–‘ì€ ê±°ë¦¬ì™€ ë¬¼ ë†’ì´ì˜ ê³±
                volume += distance * waters;
            }
    
            // ì§„í–‰í•˜ë©´ì„œ í˜„ì¬ ìœ„ì¹˜ë¥¼ ìŠ¤íƒì— ì‚½ì…
            stack.push(i);
        }
        return volume;
    }
    ```
    

## í’€ì´3. ì½”í‹€ë¦° í’€ì´

---

- ì „ì²´ ì½”ë“œ
    
    ```kotlin
    fun trap(height: IntArray): Int {
        var volume = 0
        var left = 0
        var right = height.size - 1
        var leftMax = height[left]
        var rightMax = height[right]
    
        // íˆ¬ í¬ì¸í„°ê°€ ì„œë¡œ ê²¹ì¹  ë•Œê¹Œì§€ ë°˜ë³µ
        while (left < right) {
            leftMax = height[left].coerceAtLeast(leftMax)
            rightMax = height[right].coerceAtLeast(rightMax)
    
            // ë” ë†’ì€ ìª½ì„ í–¥í•´ íˆ¬ í¬ì¸í„° ì´ë™
            if (leftMax < rightMax) {
                // ì™¼ìª½ ë§‰ëŒ€ ìµœëŒ€ ë†’ì´ì™€ì˜ ì°¨ì´ë¥¼ ë”í•˜ê³  ì™¼ìª½ í¬ì¸í„° ì´ë™
                volume += leftMax - height[left]
                left += 1
            } else {
                // ì˜¤ë¥¸ìª½ ë§‰ëŒ€ ìµœëŒ€ ë†’ì´ì™€ì˜ ì°¨ì´ë¥¼ ë”í•˜ê³  ì˜¤ë¥¸ìª½ í¬ì¸í„° ì´ë™
                volume += rightMax - height[right]
                right -= 1
            }
        }
        return volume
    }
    ```
    
    - ê¸°ì¡´ì— ìë°”ì—ì„œëŠ” `Math.max()`ë¡œ ì²˜ë¦¬í–ˆë˜ ë¶€ë¶„ì„ ì½”í‹€ë¦°ì—ì„œëŠ” `coerceAtLeast()`ë¼ëŠ” í•¨ìˆ˜ë¡œ ì²˜ë¦¬í–ˆë‹¤.
        - íŒŒë¼ë¯¸í„°ë³´ë‹¤ ê°’ì´ ì»¤ì•¼ í•¨ì„ ëœ»í•œë‹¤.
            - íŒŒë¼ë¯¸í„°ì˜ ê°’ì´ ë” í¬ë‹¤ë©´ ê·¸ ê°’ì´ ë¦¬í„´ë¨
            - ê²°êµ­ ë‘ ê°’ ì¤‘ í° ê°’ì„ ì·¨í•˜ëŠ” `Math.max()`ì™€ ì‚¬ì‹¤ìƒ ê°™ì€ ì—­í• ì„ í•œë‹¤.

| í’€ì´ | ë°©ì‹ | ì‹¤í–‰ ì‹œê°„ |
| --- | --- | --- |
| 1 | íˆ¬ í¬ì¸í„°ë¥¼ ìµœëŒ€ë¡œ ì´ë™ | 0ë°€ë¦¬ì´ˆ |
| 2 | ìŠ¤íƒ ìŒ“ê¸° | 8ë°€ë¦¬ì´ˆ |
| 3 | ì½”í‹€ë¦° í’€ì´ | ì¸¡ì •í•˜ì§€ ì•ŠìŒ |

# 9. ì„¸ ìˆ˜ì˜ í•©

---

- [https://leetcode.com/problems/3sum/](https://leetcode.com/problems/3sum/)
- ë°°ì—´ì„ ì…ë ¥ë°›ì•„ í•©ìœ¼ë¡œ 0ì„ ë§Œë“¤ ìˆ˜ ìˆëŠ” 3ê°œì˜ ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ ì¶œë ¥í•˜ë¼.
- ë‚˜ì˜ í’€ì´
    
    ```python
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        results = []
    
        for i in range(len(nums) - 2):
            # ì¤‘ë³µëœ ê°’ ê±´ë„ˆë›°ê¸°
            if i > 0 and nums[i] == nums[i - 1]:
                continue
    
            # ê°„ê²©ì„ ì¢í˜€ê°€ë©° í•© sum ê³„ì‚°
            left, right = i + 1, len(nums) - 1
            while left < right:
                sum = nums[i] + nums[left] + nums[right]
                # í•©ì´ 0ë³´ë‹¤ ì‘ë‹¤ë©´ ì™¼ìª½ í¬ì¸í„° ì´ë™
                if sum < 0:
                    left += 1
                # í•©ì´ 0ë³´ë‹¤ í¬ë‹¤ë©´ ì˜¤ë¥¸ìª½ í¬ì¸í„° ì´ë™
                elif sum > 0:
                    right -= 1
                else:
                    results.append([nums[i], nums[left], nums[right]])
    
                    # ì¤‘ë³µëœ ê°’ ê±´ë„ˆë›°ê¸°, ì´ ì²˜ë¦¬ë¥¼ í•˜ì§€ ì•Šìœ¼ë©´ ê°™ì€ ì •ë‹µì´ ë‘ ë²ˆ ë‚˜ì˜¬ ìˆ˜ ìˆë‹¤.
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    # ì •ë‹µì´ ë‚˜ì™”ìœ¼ë¯€ë¡œ íˆ¬ í¬ì¸í„° ëª¨ë‘ í•œ ì¹¸ì”© ì´ë™.
                    left += 1
                    right -= 1
    
        return results
    ```
    

## í’€ì´1. ë¸Œë£¨íŠ¸ í¬ìŠ¤ë¡œ ê³„ì‚°

---

- ì–¸ëœ» ë³´ë©´ ìˆ«ì 3ê°œë¥¼ ë§¤ë²ˆ ë°˜ë³µí•˜ë©´ O(n^3) ì •ë„ì— í’€ì´ê°€ ê°€ëŠ¥í•´ ë³´ì¸ë‹¤.
    - ê·¸ëŸ¬ë‚˜ ì´ ê²½ìš° íƒ€ì„ì•„ì›ƒì´ ë°œìƒí•´ í’€ë¦¬ì§€ ì•Šì„ ê²ƒë„ ê°™ë‹¤.
    - ì´ ë¬¸ì œëŠ” ì‹œê°„ ë³µì¡ë„ë¥¼ O(n^2) ì´ë‚´ë¡œ ì¤„ì´ê¸°ë¥¼ ìš”êµ¬í•  ê²ƒì´ë‹¤.
- ì•ë’¤ë¡œ ê°™ì€ ê°’ì´ ìˆì„ ê²½ìš°, ì´ë¥¼ ì‰½ê²Œ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ë¨¼ì € ë‹¤ìŒê³¼ ê°™ì´ `sort()` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ ì •ë ¬ë¶€í„° í•œë‹¤.
    
    ```java
    Arrays.sort(nums);
    ```
    
    - ì •ë ¬ì˜ ì‹œê°„ ë³µì¡ë„: O(n * log n)
- i, j, k ê°ê°ì˜ í¬ì¸í„°ê°€ ê³„ì† ì´ë™í•˜ë©´ì„œ i + j + k = 0ì„ ì°¾ì•„ë‚¸ë‹¤.
    - ì´ ë¸Œë£¨íŠ¸ í¬ìŠ¤ í’€ì´ì—ëŠ” ì¤‘ë³µëœ ê°’ì´ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì´ ê²½ìš° ë‹¤ìŒê³¼ ê°™ì´ `continue`ë¡œ ê±´ë„ˆë›°ë„ë¡ ì²˜ë¦¬í•œë‹¤.
        - ì´ ì²˜ë¦¬ë¥¼ í•˜ì§€ ì•Šìœ¼ë©´ ê°™ì€ ê°’ì´ ë‘ ë²ˆ ì¤‘ë³µí•´ì„œ ë‚˜ì˜¬ ìˆ˜ ìˆë‹¤.
            
            ```java
            if (i > 0 && nums[i] == nums[i - 1])
                continue;
            ```
            

- ì „ì²´ ì½”ë“œ
    
    ```java
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> results = new LinkedList<>();
        Arrays.sort(nums);
    
        // ë¸Œë£¨íŠ¸ í¬ìŠ¤ n^3 ë°˜ë³µ
        for (int i = 0; i < nums.length - 2; i++) {
            // ì¤‘ë³µëœ ê°’ ê±´ë„ˆë›°ê¸°, ì´ ì²˜ë¦¬ë¥¼ í•˜ì§€ ì•Šìœ¼ë©´ ê°™ì€ ê°’ì´ ë‘ ë²ˆ ë‚˜ì˜¬ ìˆ˜ ìˆë‹¤.
            if (i > 0 && nums[i] == nums[i - 1])
                continue;
    
            for (int j = i + 1; j < nums.length - 1; j++) {
                // ì¤‘ë³µëœ ê°’ ê±´ë„ˆë›°ê¸°, ì‚¬ìœ  ë™ì¼
                if (j > i + 1 && nums[j] == nums[j - 1])
                    continue;
                for (int k = j + 1; k < nums.length; k++) {
                    // ì¤‘ë³µëœ ê°’ ê±´ë„ˆë›°ê¸°, ì‚¬ìœ  ë™ì¼
                    if (k > j + 1 && nums[k] == nums[k - 1])
                        continue;
                    if (nums[i] + nums[j] + nums[k] == 0)
                        results.add(Arrays.asList(nums[i], nums[j], nums[k]));
                }
            }
        }
        return results;
    }
    ```
    
    - ì˜ˆìƒëŒ€ë¡œ ì´ ë°©ì‹ìœ¼ë¡œëŠ” ë¬¸ì œê°€ í’€ë¦¬ì§€ ì•ŠëŠ”ë‹¤. íƒ€ì„ì•„ì›ƒìœ¼ë¡œ í’€ì´ì— ì‹¤íŒ¨í•œë‹¤.

## í’€ì´2. íˆ¬ í¬ì¸í„°ë¡œ í•© ê³„ì‚°

---

- ì •ë ¬í•œ ë‹¤ìŒì— ië¥¼ ì¶•ìœ¼ë¡œ í•˜ê³ , ì¤‘ë³µëœ ê°’ì„ ê±´ë„ˆë›°ê²Œ í•œ ë¶€ë¶„ì€ ë‹¤ìŒê³¼ ê°™ì´ í’€ì´ #1ê³¼ ë™ì¼í•˜ë‹¤.
    
    ```java
    if (i > 0 && nums[i] == nums[i - 1])
        continue;
    ```
    
- í’€ì´ #1ê³¼ ë‹¤ë¥¸ ê³³ì€ iì˜ ë‹¤ìŒ ì§€ì ê³¼ ë§ˆì§€ë§‰ ì§€ì ì„ left, rightë¡œ ì„¤ì •í•˜ê³  ê°„ê²©ì„ ì¢í˜€ê°€ë©° sumì„ ê³„ì‚°í•˜ëŠ” ë¶€ë¶„ì´ë‹¤.
    
    ```java
    left = i + 1;
    right = nums.length - 1;
    while (left < right) {
        sum = nums[i] + nums[left] + nums[right];
        ...
    ```
    
    - ë‘ í¬ì¸í„°ê°€ ê°„ê²©ì„ ì¢í˜€ë‚˜ê°€ë©° í•© sumì„ ê³„ì‚°í•œë‹¤.
    - í•© sumì´ 0ë³´ë‹¤ ì‘ë‹¤ë©´ ê°’ì„ ë” í‚¤ì›Œì•¼ í•˜ë¯€ë¡œ leftë¥¼ ìš°ì¸¡ìœ¼ë¡œ ì´ë™í•˜ê³ , 0ë³´ë‹¤ í¬ë‹¤ë©´ ê°’ì„ ë” ì‘ê²Œ í•˜ê¸° ìœ„í•´ rightë¥¼ ì¢Œì¸¡ìœ¼ë¡œ ì´ë™í•œë‹¤.
- sumì´ 0ì´ë©´ ì •ë‹µì´ë¯€ë¡œ, ì´ ê²½ìš° ê²°ê³¼ë¥¼ ë¦¬ìŠ¤íŠ¸ ë³€ìˆ˜ resultsì— ì¶”ê°€í•œë‹¤.
    - ì¶”ê°€í•œ ë‹¤ìŒì—ëŠ” left, right ì–‘ ì˜†ìœ¼ë¡œ ë™ì¼í•œ ê°’ì´ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ê°™ì€ ì •ë‹µì´ ë‘ ë²ˆ ë‚˜ì˜¤ì§€ ì•Šë„ë¡ left += 1, right -= 1ì„ ë°˜ë³µí•´ì„œ ìŠ¤í‚µí•˜ë„ë¡ ì²˜ë¦¬í•œë‹¤.
        
        ```java
        left += 1;
        right -= 1;
        ```
        
        - ë§ˆì§€ë§‰ìœ¼ë¡œ leftë¥¼ í•œ ì¹¸ ìš°ì¸¡ìœ¼ë¡œ, rightë¥¼ í•œ ì¹¸ ì¢Œì¸¡ìœ¼ë¡œ ë” ì´ë™í•˜ê³  ë‹¤ìŒìœ¼ë¡œ ë„˜ê¸´ë‹¤.

- ì „ì²´ ì½”ë“œ
    
    ```java
    public List<List<Integer>> threeSum(int[] nums) {
        int left, right, sum;
        List<List<Integer>> results = new LinkedList<>();
        Arrays.sort(nums);
    
        for (int i = 0; i < nums.length - 2; i++) {
            // ì¤‘ë³µëœ ê°’ ê±´ë„ˆë›°ê¸°
            if (i > 0 && nums[i] == nums[i - 1])
                continue;
    
            // ê°„ê²©ì„ ì¢í˜€ê°€ë©° í•© sum ê³„ì‚°
            left = i + 1;
            right = nums.length - 1;
            while (left < right) {
                sum = nums[i] + nums[left] + nums[right];
                // í•©ì´ 0ë³´ë‹¤ ì‘ë‹¤ë©´ ì™¼ìª½ í¬ì¸í„° ì´ë™
                if (sum < 0)
                    left += 1;
                    // í•©ì´ 0ë³´ë‹¤ í¬ë‹¤ë©´ ì˜¤ë¥¸ìª½ í¬ì¸í„° ì´ë™
                else if (sum > 0)
                    right -= 1;
                else {
                    // í•©ì´ 0ì¸ ê²½ìš°ì´ë¯€ë¡œ ì •ë‹µ ì²˜ë¦¬
                    results.add(Arrays.asList(nums[i], nums[left], nums[right]));
    
                    // ì¤‘ë³µëœ ê°’ ê±´ë„ˆë›°ê¸°, ì´ ì²˜ë¦¬ë¥¼ í•˜ì§€ ì•Šìœ¼ë©´ ê°™ì€ ì •ë‹µì´ ë‘ ë²ˆ ë‚˜ì˜¬ ìˆ˜ ìˆë‹¤.
                    while (left < right && nums[left] == nums[left + 1])
                        left += 1;
                    while (left < right && nums[right] == nums[right - 1])
                        right -= 1;
                    // ì •ë‹µì´ ë‚˜ì™”ìœ¼ë¯€ë¡œ íˆ¬ í¬ì¸í„° ëª¨ë‘ í•œ ì¹¸ì”© ì´ë™.
                    // í•©ì´ 0ì¸ ìƒí™©ì´ë¯€ë¡œ ì–‘ìª½ ëª¨ë‘ ì´ë™í•´ì•¼ í•œë‹¤.
                    left += 1;
                    right -= 1;
                }
            }
        }
        return results;
    }
    ```
    
    - ì‹œê°„ ë³µì¡ë„: O(n^2)

## í’€ì´3. ì½”í‹€ë¦° í’€ì´

---

- ì „ì²´ ì½”ë“œ
    
    ```kotlin
    fun threeSum(nums: IntArray): List<List<Int>> {
        var left: Int
        var right: Int
        var sum: Int
        val results: MutableList<List<Int>> = mutableListOf()
        Arrays.sort(nums)
    
        for (i in 0 until nums.size - 2) {
            // ì¤‘ë³µëœ ê°’ ê±´ë„ˆë›°ê¸°
            if (i > 0 && nums[i] == nums[i - 1])
                continue
    
            // ê°„ê²©ì„ ì¢í˜€ê°€ë©° í•© sum ê³„ì‚°
            left = i + 1
            right = nums.size - 1
            while (left < right) {
                sum = nums[i] + nums[left] + nums[right]
                // í•©ì´ 0ë³´ë‹¤ ì‘ë‹¤ë©´ ì™¼ìª½ í¬ì¸í„° ì´ë™
                if (sum < 0)
                    left += 1
                else if (sum > 0)
                    right -= 1
                else {
                    // í•©ì´ 0ì¸ ê²½ìš°ì´ë¯€ë¡œ ì •ë‹µ ì²˜ë¦¬
                    results.add(listOf(nums[i], nums[left], nums[right]))
    
                    // ì¤‘ë³µëœ ê°’ ê±´ë„ˆë›°ê¸°, ì´ ì²˜ë¦¬ë¥¼ í•˜ì§€ ì•Šìœ¼ë©´ ê°™ì€ ì •ë‹µì´ ë‘ ë²ˆ ë‚˜ì˜¬ ìˆ˜ ìˆë‹¤.
                    while (left < right && nums[left] == nums[left + 1])
                        left += 1
                    while (left < right && nums[right] == nums[right - 1])
                        right -= 1
                    // ì •ë‹µì´ ë‚˜ì™”ìœ¼ë¯€ë¡œ íˆ¬ í¬ì¸í„° ëª¨ë‘ í•œ ì¹¸ì”© ì´ë™.
                    // í•©ì´ 0ì¸ ìƒí™©ì´ë¯€ë¡œ ì–‘ìª½ ëª¨ë‘ ì´ë™í•´ì•¼ í•œë‹¤.
                    left += 1
                    right -= 1
                }
            }
        }
        return results
    }
    ```
    
    - `MutableList`ëŠ” `List`ë¥¼ ìƒì†ë°›ê¸° ë•Œë¬¸ì— ë¦¬í„´ íƒ€ì…ì´ `List`ì¼ ë•Œ `MutableList`ë¥¼ ë¦¬í„´í•˜ëŠ” ê²Œ ê°€ëŠ¥í•˜ë‹¤. í•˜ì§€ë§Œ ë°˜ëŒ€ëŠ” ë¶ˆê°€ëŠ¥í•˜ë‹¤.

| í’€ì´ | ë°©ì‹ | ì‹¤í–‰ ì‹œê°„ |
| --- | --- | --- |
| 1 | ë¸Œë£¨íŠ¸ í¬ìŠ¤ë¡œ ê³„ì‚° | íƒ€ì„ì•„ì›ƒ |
| 2 | íˆ¬ í¬ì¸í„°ë¡œ í•© ê³„ì‚° | 28ë°€ë¦¬ì´ˆ |
| 3 | ì½”í‹€ë¦° í’€ì´ | ì¸¡ì •í•˜ì§€ ì•ŠìŒ |

# 10. ë°°ì—´ íŒŒí‹°ì…˜ 1

---

- [https://leetcode.com/problems/array-partition/](https://leetcode.com/problems/array-partition/)
- nê°œì˜ í˜ì–´ë¥¼ ì´ìš©í•œ min(a, b)ì˜ í•©ìœ¼ë¡œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ìˆ˜ë¥¼ ì¶œë ¥í•˜ë¼.
- ë‚˜ì˜ í’€ì´
    
    ```python
    def arrayPairSum(self, nums: List[int]) -> int:
        nums.sort()
        result = 0
        
        for i in range(0, len(nums), 2):
            result += nums[i]
        
        return result
    ```
    

## í’€ì´1. ì˜¤ë¦„ì°¨ìˆœ í’€ì´

---

- í˜ì–´ì˜ `min()`ì„ í•©ì‚°í–ˆì„ ë•Œ ìµœëŒ€ê°€ ë˜ë ¤ë©´ ê²°êµ­ ê°ê°ì˜ `min()`ì´ ê°€ê¸‰ì  ì»¤ì•¼ í•œë‹¤ëŠ” ëœ»ì´ê³ , ë’¤ì—ì„œë¶€í„° ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì§‘ì–´ë„£ìœ¼ë©´ í•­ìƒ ìµœëŒ€ `min()` í˜ì–´ë¥¼ ìœ ì§€í•  ìˆ˜ ìˆë‹¤.
    - ë°°ì—´ ì…ë ¥ê°’ì˜ ê¸¸ì´ëŠ” í•­ìƒ 2nê°œì´ë¯€ë¡œ ì•ì—ì„œë¶€í„° ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì§‘ì–´ë„£ì–´ë„ ê²°ê³¼ëŠ” ê°™ì„ ê²ƒì´ë‹¤.

- ì „ì²´ ì½”ë“œ
    
    ```java
    public int arrayPairSum(int[] nums) {
        int sum = 0;
        List<Integer> pair = new ArrayList<>();
        Arrays.sort(nums);
    
        // ì•ì—ì„œë¶€í„° ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ë°˜ë³µ
        for (int n : nums) {
            pair.add(n);
            // í˜ì–´ ë³€ìˆ˜ì— ê°’ì´ 2ê°œ ì±„ì›Œì§€ë©´ min()ì„ í•©ì‚°í•˜ê³  ë³€ìˆ˜ ì´ˆê¸°í™”
            if (pair.size() == 2) {
                sum += Collections.min(pair);
                pair.clear();
            }
        }
        return sum;
    }
    ```
    

## í’€ì´2. ì§ìˆ˜ ë²ˆì§¸ ê°’ ê³„ì‚°

---

- ì´ë ‡ê²Œ í˜ì–´ì— ëŒ€í•´ ì¼ì¼ì´ `min()` ê°’ì„ êµ¬í•˜ì§€ ì•Šì•„ë„ ì§ìˆ˜ ë²ˆì§¸ ì¸ë±ìŠ¤ì˜ ê°’ì„ ë”í•˜ë©´ ë  ê²ƒ ê°™ë‹¤.
    - ì •ë ¬ëœ ìƒíƒœì—ì„œëŠ” ì§ìˆ˜ ë²ˆì§¸ì— í•­ìƒ ì‘ì€ ê°’ì´ ìœ„ì¹˜í•˜ê¸° ë•Œë¬¸ì´ë‹¤.
    - ë¶ˆí•„ìš”í•œ `min()` ê³„ì‚°ì´ ìƒëµë˜ì–´ ì‹¤í–‰ ì†ë„ë„ ë” ë¹ ë¥¼ ê²ƒì´ë‹¤.

- ì „ì²´ ì½”ë“œ
    
    ```java
    public int arrayPairSum(int[] nums) {
        int sum = 0;
        Arrays.sort(nums);
    
        // ì•ì—ì„œë¶€í„° ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì¸ë±ìŠ¤ ë°˜ë³µ
        for (int i = 0; i < nums.length; i++) {
            // ì§ìˆ˜ ë²ˆì§¸ì¼ ë•Œ ê°’ì˜ í•© ê³„ì‚°
            if (i % 2 == 0)
                sum += nums[i];
        }
        return sum;
    }
    ```
    

## í’€ì´3. ì½”í‹€ë¦° í’€ì´

---

- ì „ì²´ ì½”ë“œ
    
    ```kotlin
    fun arrayPairSum(nums: IntArray): Int {
        var sum = 0
        nums.sort()
    
        // ì•ì—ì„œë¶€í„° ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì¸ë±ìŠ¤ ë°˜ë³µ
        for ((i, n) in nums.withIndex()) {
            // ì§ìˆ˜ ë²ˆì§¸ì¼ ë•Œ ê°’ì˜ í•© ê³„ì‚°
            if (i % 2 == 0)
                sum += n
        }
        return sum
    }
    ```
    

| í’€ì´ | ë°©ì‹ | ì‹¤í–‰ ì‹œê°„ |
| --- | --- | --- |
| 1 | ì˜¤ë¦„ì°¨ìˆœ í’€ì´ | 41ë°€ë¦¬ì´ˆ |
| 2 | ì§ìˆ˜ ë²ˆì§¸ ê°’ ê³„ì‚° | 11ë°€ë¦¬ì´ˆ |
| 3 | ì½”í‹€ë¦° í’€ì´ | ì¸¡ì •í•˜ì§€ ì•ŠìŒ |

# 11. ìì‹ ì„ ì œì™¸í•œ ë°°ì—´ì˜ ê³±

---

- [https://leetcode.com/problems/product-of-array-except-self/](https://leetcode.com/problems/product-of-array-except-self/)
- ë°°ì—´ì„ ì…ë ¥ë°›ì•„ output[i]ê°€ ìì‹ ì„ ì œì™¸í•œ ë‚˜ë¨¸ì§€ ëª¨ë“  ì—˜ë¦¬ë¨¼íŠ¸ì˜ ê³±ì…ˆ ê²°ê³¼ê°€ ë˜ë„ë¡ ì¶œë ¥í•˜ë¼.
- ë‚˜ì˜ í’€ì´
    
    ```python
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        result = [1] * len(nums)
        
        multiply = 1
        for i in range(len(nums)):
            result[i] = multiply
            multiply *= nums[i]
        
        multiply = 1
        for i in range(len(nums) - 1, -1, -1):
            result[i] *= multiply
            multiply *= nums[i]
        
        return result
    ```
    

## í’€ì´1. ì™¼ìª½ ê³±ì…ˆ ê²°ê³¼ì— ì˜¤ë¥¸ìª½ ê°’ì„ ì°¨ë¡€ëŒ€ë¡œ ê³±í•˜ê¸°

---

- ì´ ë¬¸ì œì—ëŠ” ì¤‘ìš”í•œ ì œì•½ ì‚¬í•­ì´ ìˆë‹¤: ë‚˜ëˆ—ì…ˆì„ í•˜ì§€ ì•Šê³  O(n)ì— í’€ì´í•˜ë¼
- ê°€ëŠ¥í•œ í’€ì´ ë°©ë²•ì€ í•œ ê°€ì§€ë¿ì´ë‹¤: ìê¸° ìì‹ ì„ ì œì™¸í•˜ê³  ì™¼ìª½ì˜ ê³±ì…ˆ ê²°ê³¼ì™€ ì˜¤ë¥¸ìª½ì˜ ê³±ì…ˆ ê²°ê³¼ë¥¼ ê³±í•˜ëŠ” ë°©ë²•
    - ê³µê°„ ë³µì¡ë„: O(n)
        - ë³„ë„ì˜ ë¦¬ìŠ¤íŠ¸ ë³€ìˆ˜ë¥¼ ë§Œë“¤ê³  ê·¸ ë³€ìˆ˜ì— ìš°ì¸¡ ê³±ì…ˆ ê²°ê³¼ë¥¼ ë„£ìœ¼ë©´
    - ê³µê°„ ë³µì¡ë„: O(1)
        - ê¸°ì¡´ result ë³€ìˆ˜ë¥¼ ì¬í™œìš©í•œë‹¤ë©´

- ì „ì²´ ì½”ë“œ
    
    ```java
    public int[] productExceptSelf(int[] nums) {
        int[] result = new int[nums.length];
        // ì™¼ìª½ ê³±ì…ˆ
        int p = 1;
        for (int i = 0; i < nums.length; i++) {
            result[i] = p;
            // ì™¼ìª½ ê³±ì…ˆ ê²°ê³¼
            p *= nums[i];
        }
        // ì˜¤ë¥¸ìª½ ê³±ì…ˆ, ì™¼ìª½ ê³±ì…ˆ ê²°ê³¼ì— ì°¨ë¡€ëŒ€ë¡œ ê³±í•˜ê¸°
        p = 1;
        for (int i = nums.length - 1; i >= 0; i--) {
            result[i] *= p;
            // ì˜¤ë¥¸ìª½ ê³±ì…ˆ ê²°ê³¼
            p *= nums[i];
        }
        return result;
    }
    ```
    

## í’€ì´2. ì½”í‹€ë¦° í’€ì´

---

- 2ê°€ì§€ ì°¨ì´ì ì´ ìˆë‹¤.
    - ìë°” í’€ì´ì˜ ê²°ê³¼ ë³€ìˆ˜ëŠ” ì›ì‹œí˜•ìœ¼ë¡œ ì§€ì •í–ˆìœ¼ë‚˜ ì½”í‹€ë¦°ì€ ì›ì‹œí˜•ì„ ì§€ì›í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— `IntArray`ë¡œ ì„ ì–¸í–ˆë‹¤.
    - ì¸ë±ìŠ¤ë¥¼ ìˆœíšŒí•  ë•Œ ìë°”ëŠ” ì•ì—ì„œ í•œ ë²ˆ, ë’¤ì—ì„œ í•œ ë²ˆ ìˆœíšŒí–ˆë‹¤. ì‚¬ì‹¤ ê°€ë…ì„±ì´ ì¢‹ì§„ ì•Šë‹¤.
        - ì½”í‹€ë¦°ì€ ë§¤ìš° ì§ê´€ì ìœ¼ë¡œ í‘œí˜„ì´ ê°€ëŠ¥í•˜ë‹¤.

- ì „ì²´ ì½”ë“œ
    
    ```kotlin
    fun productExceptSelf(nums: IntArray): IntArray {
        val result = IntArray(nums.size)
        // ì™¼ìª½ ê³±ì…ˆ
        var p = 1
        for (i in nums.indices) {
            result[i] = p
            // ì™¼ìª½ ê³±ì…ˆ ê²°ê³¼
            p *= nums[i]
        }
        // ì˜¤ë¥¸ìª½ ê³±ì…ˆ, ì™¼ìª½ ê³±ì…ˆ ê²°ê³¼ì— ì°¨ë¡€ëŒ€ë¡œ ê³±í•˜ê¸°
        p = 1
        for (i in nums.indices.reversed()) {
            // ì™¼ìª½ ê³±ì…ˆ ê²°ê³¼ì— ì°¨ë¡€ëŒ€ë¡œ ê³±í•œ ìµœì¢… ê²°ê³¼
            result[i] *= p
            // ì˜¤ë¥¸ìª½ ê³±ì…ˆ ê²°ê³¼
            p *= nums[i]
        }
        return result
    }
    ```
    

| í’€ì´ | ë°©ì‹ | ì‹¤í–‰ ì‹œê°„ |
| --- | --- | --- |
| 1 | ì™¼ìª½ ê³±ì…ˆ ê²°ê³¼ì— ì˜¤ë¥¸ìª½ ê°’ì„ ì°¨ë¡€ëŒ€ë¡œ ê³±í•˜ê¸° | 2ë°€ë¦¬ì´ˆ |
| 2 | ì½”í‹€ë¦° í’€ì´ | ì¸¡ì •í•˜ì§€ ì•ŠìŒ |

# 12. ì£¼ì‹ì„ ì‚¬ê³ íŒ”ê¸° ê°€ì¥ ì¢‹ì€ ì‹œì 

---

- [https://leetcode.com/problems/best-time-to-buy-and-sell-stock/](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
- í•œ ë²ˆì˜ ê±°ë˜ë¡œ ë‚¼ ìˆ˜ ìˆëŠ” ìµœëŒ€ ì´ìµì„ ì‚°ì¶œí•˜ë¼.
- ë‚˜ì˜ í’€ì´
    
    ```python
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) <= 1:
            return 0
        buyIdx, sellIdx, minIdx, answer = 0, 1, 0, 0
    
        while sellIdx < len(prices):
            if prices[buyIdx] > prices[minIdx]:
                buyIdx = minIdx
            answer = max(answer, prices[sellIdx] - prices[buyIdx])
                
            if prices[sellIdx] < prices[minIdx]:
                minIdx = sellIdx
            sellIdx += 1
    
        return answer
    ```
    

## í’€ì´1. ë¸Œë£¨íŠ¸ í¬ìŠ¤ë¡œ ê³„ì‚°

---

- ì²˜ìŒë¶€í„° O(n^2)ìœ¼ë¡œ ì‚¬ê³ íŒ”ê³ ë¥¼ ë°˜ë³µí•˜ë©´, ë§ˆì§€ë§‰ì— ìµœëŒ€ ì´ìµì„ ì‚°ì¶œí•  ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤.

- ì „ì²´ ì½”ë“œ
    
    ```java
    public int maxProfit(int[] prices) {
        int maxProfit = 0;
        // êµ¬ë§¤ ì‹œì  ìˆœíšŒ, ì²˜ìŒë¶€í„° ëê¹Œì§€ ì°¨ë¡€ëŒ€ë¡œ ë°˜ë³µí•œë‹¤.
        for (int i = 0; i < prices.length; i++) {
            // íŒë§¤ ì‹œì  ìˆœíšŒ, êµ¬ë§¤ ë‹¤ìŒë¶€í„° ëê¹Œì§€ ì°¨ë¡€ëŒ€ë¡œ ë°˜ë³µí•œë‹¤.
            for (int j = i + 1; j < prices.length; j++) {
                // íŒë§¤ ì‹œì  ê°€ê²©ì—ì„œ êµ¬ë§¤ ì‹œì  ê°€ê²©ì„ ëº„ ë•Œ ê°€ì¥ ë†’ì€ ê¸ˆì•¡ ì°¾ê¸°
                maxProfit = Math.max(maxProfit, prices[j] - prices[i]);
            }
        }
        return maxProfit;
    }
    ```
    
    - í•˜ì§€ë§Œ ì•ˆíƒ€ê¹ê²Œë„ ì´ í’€ì´ëŠ” íƒ€ì„ì•„ì›ƒìœ¼ë¡œ í’€ë¦¬ì§€ ì•ŠëŠ”ë‹¤.

## í’€ì´2. ì €ì ê³¼ í˜„ì¬ ê°’ê³¼ì˜ ì°¨ì´ ê³„ì‚°

---

- í˜„ì¬ ê°’ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ê°€ ìš°ì¸¡ìœ¼ë¡œ ì´ë™í•˜ë©´ì„œ ì´ì „ ìƒíƒœì˜ ì €ì ì„ ê¸°ì¤€ìœ¼ë¡œ ê°€ê²© ì°¨ì´ë¥¼ ê³„ì‚°í•˜ê³ , ë§Œì•½ ê°€ê²©ì´ í´ ê²½ìš° ìµœëŒ“ê°’ì„ ê³„ì† êµì²´í•´ ë‚˜ê°€ëŠ” í˜•íƒœë¡œ O(n) í’€ì´ê°€ ê°€ëŠ¥í•  ê²ƒ ê°™ë‹¤.

- ì „ì²´ ì½”ë“œ
    
    ```java
    public int maxProfit(int[] prices) {
        // ìµœëŒ€ ì´ìµì€ 0, ì €ì ì€ ì„ì‹œë¡œ ì²« ë²ˆì§¸ ê°’ìœ¼ë¡œ ì§€ì •
        int maxProfit = 0, minPrice = prices[0];
        // í˜„ì¬ ê°’ì„ ìš°ì¸¡ìœ¼ë¡œ ì°¨ë¡€ëŒ€ë¡œ ì´ë™í•˜ë©´ì„œ ê³„ì‚°
        for (int price : prices) {
            // ì§€ê¸ˆê¹Œì§€ ì €ì  ê³„ì‚°
            minPrice = Math.min(minPrice, price);
            // í˜„ì¬ ê°’ê³¼ ì €ì ì˜ ì°¨ì´ê°€ ìµœëŒ€ ì´ìµì¸ ê²½ìš° êµì²´
            maxProfit = Math.max(maxProfit, price - minPrice);
        }
        return maxProfit;
    }
    ```
    

## í’€ì´3. ì½”í‹€ë¦° í’€ì´

---

- ì „ì²´ ì½”ë“œ
    
    ```kotlin
    fun maxProfit(prices: IntArray): Int {
        var maxProfit = 0
        // ì„ì‹œë¡œ ì²« ë²ˆì§¸ ê°’ì„ ì €ì ìœ¼ë¡œ ì§€ì •
        var minPrice = prices[0]
        // í˜„ì¬ ê°’ì„ ìš°ì¸¡ìœ¼ë¡œ ì°¨ë¡€ëŒ€ë¡œ ì´ë™í•˜ë©´ì„œ ê³„ì‚°
        for (price in prices) {
            // ì§€ê¸ˆê¹Œì§€ ì €ì  ê³„ì‚°
            minPrice = minPrice.coerceAtMost(price)
            // í˜„ì¬ ê°’ê³¼ ì €ì ì˜ ì°¨ì´ê°€ ìµœëŒ€ ì´ìµì¸ ê²½ìš° êµì²´
            maxProfit = maxProfit.coerceAtLeast(price - minPrice)
        }
        return maxProfit
    }
    ```
    

| í’€ì´ | ë°©ì‹ | ì‹¤í–‰ ì‹œê°„ |
| --- | --- | --- |
| 1 | ë¸Œë£¨íŠ¸ í¬ìŠ¤ë¡œ ê³„ì‚° | íƒ€ì„ì•„ì›ƒ |
| 2 | ì €ì ê³¼ í˜„ì¬ ê°’ì˜ ì°¨ì´ ê³„ì‚° | 2ë°€ë¦¬ì´ˆ |
| 3 | ì½”í‹€ë¦° í’€ì´ | ì¸¡ì •í•˜ì§€ ì•ŠìŒ |